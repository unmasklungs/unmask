---
// D3 will be imported on the client side

// Define props
export interface Props {
  width?: number;
  height?: number;
}

// Set default props
const { width = 1200, height = 675 } = Astro.props;

// This will be rendered on the client
---

<div class="map-container" style={`width: 100%; max-width: ${width}px; margin: 0 auto;`}>
  <div id="map" style={`width: 100%; height: ${height}px; position: relative;`}>
    <div id="tooltip" class="tooltip"></div>
  </div>
  <div id="info-panel" class="info-panel mt-4 border border-gray-200 rounded-lg p-4 bg-white shadow-sm">
    <div id="info-content">
      <p class="text-gray-500">Click on a region to see details</p>
    </div>
  </div>
</div>

<!-- Client-side JavaScript for the interactive map -->
<script>
  // Define TypeScript interface for province properties from GeoJSON
  interface ProvinceProperties {
    ERUID: string;
    DGUID: string;
    ERNAME: string;
    LANDAREA: number;
    PRUID: string;
  }

  // Wait for the DOM to be fully loaded before initializing the map
  document.addEventListener('DOMContentLoaded', async () => {
    // Dynamically import D3 for client-side usage
    const d3 = await import('d3');
    let container: HTMLElement | null = null;
    try {
      // Select the map container
      container = document.getElementById('map');
      if (!container) return;

      // Set up the SVG
      const containerEl = container;
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      
      // Create SVG element
      const svg = d3.select(containerEl)
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', `0 0 ${containerWidth} ${containerHeight}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      // Add a group for the map features
      const g = svg.append('g');

      // Create a path generator with a default projection (will be updated after loading data)
      let projection = d3.geoIdentity();
      let path = d3.geoPath().projection(projection);

      // Tooltip and info panel setup
      const tooltip = d3.select('#tooltip');
      const infoPanel = d3.select('#info-content');
      
      // Function to handle mouseover events
      function handleMouseOver(
        this: SVGPathElement,
        event: MouseEvent,
        d: d3.ExtendedFeature<d3.GeoGeometryObjects | null, ProvinceProperties>
      ) {
        if (!d.properties) return;
        
        d3.select(this)
          .transition()
          .duration(200)
          .attr('opacity', 0.7)
          .attr('stroke', '#333')
          .attr('stroke-width', 1.5);
          
        // Show only the region name near the mouse
        const [x, y] = d3.pointer(event, container);
        const name = d.properties.ERNAME || 'Unknown Region';
        
        tooltip
          .style('left', `${x + 10}px`)
          .style('top', `${y - 10}px`)
          .style('opacity', 1)
          .text(name);
      }

      // Function to handle mouseout events
      function handleMouseOut(this: SVGPathElement) {
        d3.select(this)
          .transition()
          .duration(200)
          .attr('opacity', 1)
          .attr('stroke', '#fff')
          .attr('stroke-width', 0.5);
          
        // Hide the tooltip
        tooltip.style('opacity', 0);
      }

      // Function to handle click events
      function handleClick(
        this: SVGPathElement,
        event: MouseEvent,
        d: d3.ExtendedFeature<d3.GeoGeometryObjects | null, ProvinceProperties>
      ) {
        if (!d.properties) return;
        
        // Toggle selection
        const isSelected = d3.select(this).classed('selected');
        
        // Reset all selections
        d3.selectAll('path').classed('selected', false);
        
        // Toggle the clicked path
        d3.select(this).classed('selected', !isSelected);
        
        if (!isSelected) {
          // Show info in the side panel
          const name = d.properties.ERNAME || 'Unknown District';
          const area = (d.properties.LANDAREA || 0).toLocaleString('en-CA', {
            maximumFractionDigits: 0
          });
          
          infoPanel.html(`
            <div class="space-y-3">
              <h4 class="text-lg font-semibold border-b pb-2">${name}</h4>
              <div class="space-y-2">
                <div class="flex justify-between">
                  <span class="text-gray-600">Area:</span>
                  <span class="font-medium">${area} kmÂ²</span>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-600">Region ID:</span>
                  <span class="font-mono">${d.properties.ERUID}</span>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-600">Province ID:</span>
                  <span>${d.properties.PRUID}</span>
                </div>
                <div class="pt-2 mt-2 border-t">
                  <h5 class="font-medium mb-1">Radon Level (Random data ,to be fixed)</h5>
                  <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div class="bg-blue-600 h-2.5 rounded-full" style="width: ${Math.random() * 100}%"></div>
                  </div>
                  <div class="text-right text-sm text-gray-500 mt-1">${(Math.random() * 10).toFixed(1)} pCi/L</div>
                </div>
              </div>
            </div>
          `);
        } else {
          infoPanel.html('<p class="text-gray-500">Click on a region to see details</p>');
        }
      }

      // Load the GeoJSON data for Canadian provinces
      let geojson;
      try {
        const response = await fetch('/data/your-map-ultra-small.geojson', {
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          cache: 'no-cache' // Prevent caching issues during development
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        geojson = await response.json();
        console.log('GeoJSON loaded successfully');
        
        // Update projection with the loaded GeoJSON data
        projection = d3.geoIdentity()
          .reflectY(true)  // Flip Y coordinates if needed
          .fitSize([containerWidth, containerHeight], geojson);
          
        // Update the path generator with the new projection
        path = d3.geoPath().projection(projection);
        
        // Log the bounds to help with debugging
        const [[x0, y0], [x1, y1]] = d3.geoBounds(geojson);
        console.log('GeoJSON bounds:', { x0, y0, x1, y1 });
        
      } catch (error) {
        console.error('Failed to load GeoJSON:', error);
        throw error;
      }

      // Color scale for provinces/territories with more distinct colors
      const color = d3.scaleOrdinal([
        '#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f',
        '#edc949', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ab',
        '#8c6d31', '#b3b3b3', '#9c9ede', '#d4a6c8', '#86bcb6',
        '#f1ce63', '#b5c8d1', '#d37295', '#f1a208', '#a0cbe8'
      ]);
      
      // Add a title to the map
      svg.append('text')
        .attr('x', containerWidth / 2)
        .attr('y', 30)
        .attr('text-anchor', 'middle')
        .style('font-size', '20px')
        .style('font-weight', 'bold')
        .text('Canadian Electoral Districts');
      
      // Function to get color based on PRUID (province code)
      const getProvinceColor = (d: d3.ExtendedFeature<d3.GeoGeometryObjects | null, ProvinceProperties>) => {
        const pruid = d.properties?.PRUID || 'default';
        return color(pruid);
      };

      // Draw the map with better styling
      const paths = g.selectAll('path')
        .data(geojson.features)
        .enter()
        .append('path')
        .attr('d', path)
        .attr('fill', getProvinceColor)
        .attr('stroke', '#fff')
        .attr('stroke-width', 0.5)
        .attr('opacity', 0.9)
        .attr('data-highlighted', 'false')
        .style('transition', 'all 0.2s ease')
        .on('mouseover', handleMouseOver)
        .on('mouseout', handleMouseOut)
        .on('click', handleClick);
        
      // Log any rendering errors
      paths.each(function(d, i) {
        const pathElement = d3.select(this);
        if (!pathElement.node()) {
          console.error('Failed to render path for feature:', i, d);
        }
      });

      // Add zoom behavior with better constraints
      const zoom = d3.zoom<SVGSVGElement, unknown>()
        .scaleExtent([0.8, 8])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
        });

      // Apply initial zoom to fit the map nicely
      svg.call(zoom);
      
      // Reset to the initial zoom level (same as reset button)
      svg.call(zoom.transform, d3.zoomIdentity);

      // Add reset zoom button
      const resetButton = document.createElement('button');
      resetButton.className = 'reset-zoom';
      resetButton.textContent = 'Reset Zoom';
      resetButton.onclick = () => {
        svg.transition()
          .duration(750)
          .call(zoom.transform, d3.zoomIdentity);
      };
      
      // Insert the reset button
      containerEl.parentNode?.insertBefore(resetButton, containerEl);

    } catch (error) {
      console.error('Error loading the map:', error);
      if (container) {
        container.innerHTML = `
          <div class="p-4 bg-red-50 text-red-800 rounded">
            <p class="font-bold">Error loading the map</p>
            <p class="text-sm">${error.message || 'Please check your internet connection and try again.'}</p>
          </div>
        `;
      }
    }
  });
</script>

<style>
  .map-container {
    border: 1px solid #e2e8f0;
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    background: white;
    padding: 1rem;
  }
  
  .info-panel {
    margin-top: 1rem;
    min-height: 150px;
  }
  
  .info-panel h3 {
    color: #1a365d;
    margin-bottom: 1rem;
  }
  
  path {
    transition: all 0.2s ease;
    cursor: pointer;
  }
  
  .tooltip {
    position: absolute;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    padding: 8px 12px;
    pointer-events: none;
    font-size: 14px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 10;
    white-space: nowrap;
    font-weight: 500;
  }
  
  .reset-zoom {
    position: absolute;
    top: 10px;
    right: 10px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    padding: 6px 12px;
    font-size: 13px;
    cursor: pointer;
    z-index: 100;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    transition: all 0.2s ease;
  }
  
  .reset-zoom:hover {
    background: #f8f9fa;
    transform: translateY(-1px);
  }
  
  .reset-zoom:active {
    transform: translateY(0);
  }
</style>
