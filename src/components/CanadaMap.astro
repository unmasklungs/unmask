---
// D3 will be imported on the client side

// Define props
export interface Props {
  width?: number;
  height?: number;
}

// Set default props
const { width = 800, height = 600 } = Astro.props;

// This will be rendered on the client
---

<div class="map-container" style={`width: 100%; max-width: ${width}px; margin: 0 auto;`}>
  <div id="map" style={`width: 100%; height: ${height}px; position: relative;`}>
    <div id="tooltip" class="tooltip"></div>
  </div>
</div>

<!-- Client-side JavaScript for the interactive map -->
<script>
  // Define TypeScript interface for province properties from GeoJSON
  interface ProvinceProperties {
    ERUID: string;
    DGUID: string;
    ERNAME: string;
    LANDAREA: number;
    PRUID: string;
  }

  // Wait for the DOM to be fully loaded before initializing the map
  document.addEventListener('DOMContentLoaded', async () => {
    // Dynamically import D3 for client-side usage
    const d3 = await import('d3');
    let container: HTMLElement | null = null;
    try {
      // Select the map container
      container = document.getElementById('map');
      if (!container) return;

      // Set up the SVG
      const containerEl = container;
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      
      // Create SVG element
      const svg = d3.select(containerEl)
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', `0 0 ${containerWidth} ${containerHeight}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      // Add a group for the map features
      const g = svg.append('g');

      // Create a path generator with a default projection (will be updated after loading data)
      let projection = d3.geoIdentity();
      let path = d3.geoPath().projection(projection);

      // Tooltip setup
      const tooltip = d3.select('#tooltip');
      
      // Function to handle mouseover events
      function handleMouseOver(
        this: SVGPathElement,
        event: MouseEvent,
        d: d3.ExtendedFeature<d3.GeoGeometryObjects | null, ProvinceProperties>
      ) {
        if (!d.properties) return;
        
        d3.select(this)
          .transition()
          .duration(200)
          .attr('opacity', 0.7)
          .attr('stroke', '#333')
          .attr('stroke-width', 1.5);

        // Show tooltip with district info
        const [x, y] = d3.pointer(event, container);
        const name = d.properties.ERNAME || 'Unknown District';
        const area = (d.properties.LANDAREA || 0).toLocaleString('en-CA', {
          maximumFractionDigits: 0
        });
        
        tooltip
          .style('left', `${x + 10}px`)
          .style('top', `${y - 10}px`)
          .style('opacity', 1)
          .html(`
            <div class="font-bold">${name}</div>
            <div>Area: ${area} kmÂ²</div>
            <div>Region ID: ${d.properties.ERUID}</div>
          `);
      }

      // Function to handle mouseout events
      function handleMouseOut(this: SVGPathElement) {
        d3.select(this)
          .transition()
          .duration(200)
          .attr('opacity', 1)
          .attr('stroke', '#fff')
          .attr('stroke-width', 0.8);
        
        // Hide tooltip
        tooltip.style('opacity', 0);
      }

      // Function to handle click events
      function handleClick(
        this: SVGPathElement,
        event: MouseEvent,
        d: d3.ExtendedFeature<d3.GeoGeometryObjects | null, ProvinceProperties>
      ) {
        const name = d.properties?.ERNAME || 'Unknown District';
        console.log(`Clicked on: ${name}`, d.properties);
        
        // Toggle highlight on click
        const isHighlighted = d3.select(this).attr('data-highlighted') === 'true';
        
        // Reset all highlights
        d3.selectAll('path').attr('data-highlighted', 'false');
        
        if (!isHighlighted) {
          // Highlight the clicked district
          d3.select(this)
            .attr('data-highlighted', 'true')
            .attr('opacity', 1)
            .attr('stroke', '#ff6b6b')
            .attr('stroke-width', 2);
        } else {
          // If already highlighted, reset all
          d3.selectAll('path')
            .attr('opacity', 1)
            .attr('stroke', '#fff')
            .attr('stroke-width', 0.8);
        }
      }

      // Load the GeoJSON data for Canadian provinces
      let geojson;
      try {
        const response = await fetch('/data/your-map-ultra-small.geojson', {
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          cache: 'no-cache' // Prevent caching issues during development
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        geojson = await response.json();
        console.log('GeoJSON loaded successfully');
        
        // Update projection with the loaded GeoJSON data
        projection = d3.geoIdentity()
          .reflectY(true)  // Flip Y coordinates if needed
          .fitSize([containerWidth, containerHeight], geojson);
          
        // Update the path generator with the new projection
        path = d3.geoPath().projection(projection);
        
        // Log the bounds to help with debugging
        const [[x0, y0], [x1, y1]] = d3.geoBounds(geojson);
        console.log('GeoJSON bounds:', { x0, y0, x1, y1 });
        
      } catch (error) {
        console.error('Failed to load GeoJSON:', error);
        throw error;
      }

      // Color scale for provinces/territories with more distinct colors
      const color = d3.scaleOrdinal([
        '#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f',
        '#edc949', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ab',
        '#8c6d31', '#b3b3b3', '#9c9ede', '#d4a6c8', '#86bcb6',
        '#f1ce63', '#b5c8d1', '#d37295', '#f1a208', '#a0cbe8'
      ]);
      
      // Add a title to the map
      svg.append('text')
        .attr('x', containerWidth / 2)
        .attr('y', 30)
        .attr('text-anchor', 'middle')
        .style('font-size', '20px')
        .style('font-weight', 'bold')
        .text('Canadian Electoral Districts');
      
      // Function to get color based on PRUID (province code)
      const getProvinceColor = (d: d3.ExtendedFeature<d3.GeoGeometryObjects | null, ProvinceProperties>) => {
        const pruid = d.properties?.PRUID || 'default';
        return color(pruid);
      };

      // Draw the map with better styling
      const paths = g.selectAll('path')
        .data(geojson.features)
        .enter()
        .append('path')
        .attr('d', path)
        .attr('fill', getProvinceColor)
        .attr('stroke', '#fff')
        .attr('stroke-width', 0.8)
        .attr('opacity', 0.9)
        .attr('data-highlighted', 'false')
        .style('transition', 'all 0.2s ease')
        .on('mouseover', handleMouseOver)
        .on('mouseout', handleMouseOut)
        .on('click', handleClick);
        
      // Log any rendering errors
      paths.each(function(d, i) {
        const pathElement = d3.select(this);
        if (!pathElement.node()) {
          console.error('Failed to render path for feature:', i, d);
        }
      });

      // Add zoom behavior with better constraints
      const zoom = d3.zoom()
        .scaleExtent([0.2, 8])  // Allow more zoom out
        .translateExtent([[0, 0], [containerWidth, containerHeight]])
        .on('zoom', (event) => {
          // Apply the transform to the group
          g.attr('transform', event.transform);
          
          // Adjust stroke width based on zoom level
          const scale = event.transform.k;
          g.selectAll('path')
            .attr('stroke-width', 0.8 / scale);
        });
        
      // Add a slight initial zoom to fit the map better
      svg.call(zoom.transform, d3.zoomIdentity.scale(0.8));

      svg.call(zoom);

      // Add reset zoom button
      const resetButton = document.createElement('button');
      resetButton.className = 'reset-zoom';
      resetButton.textContent = 'Reset Zoom';
      resetButton.onclick = () => {
        svg.transition()
          .duration(750)
          .call(zoom.transform, d3.zoomIdentity);
      };
      
      // Insert the reset button
      containerEl.parentNode?.insertBefore(resetButton, containerEl);

    } catch (error) {
      console.error('Error loading the map:', error);
      if (container) {
        container.innerHTML = `
          <div class="p-4 bg-red-50 text-red-800 rounded">
            <p class="font-bold">Error loading the map</p>
            <p class="text-sm">${error.message || 'Please check your internet connection and try again.'}</p>
          </div>
        `;
      }
    }
  });
</script>

<style>
  .map-container {
    border: 1px solid #e2e8f0;
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    position: relative;
    background: #f8fafc;
  }
  
  path {
    transition: all 0.2s ease;
    cursor: pointer;
  }
  
  .tooltip {
    position: absolute;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    padding: 8px 12px;
    pointer-events: none;
    font-size: 14px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 10;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    min-width: 120px;
  }
  
  .reset-zoom {
    position: absolute;
    top: 10px;
    right: 10px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    padding: 6px 12px;
    font-size: 13px;
    cursor: pointer;
    z-index: 100;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    transition: all 0.2s ease;
  }
  
  .reset-zoom:hover {
    background: #f8f9fa;
    transform: translateY(-1px);
  }
  
  .reset-zoom:active {
    transform: translateY(0);
  }
</style>
